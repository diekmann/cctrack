/*
 * cctrack_controller.c
 *
 * PID controller
 *
 * Copyright (c) 2012, Cornelius Diekmann
 * All rights reserved.
 */

#include <linux/time.h>

#include "cctrack_controller.h"
#include "cctrack.h"
#include "cctrack_util.h"




/* ****************  global vars  ******************** */



/* ****************  init & cleanup functions  ******************** */
void cctrack_controller_init(void){}

void noinline cctrack_controller_exit(void){}


void cctrack_controller_init_state(struct cctrack_pid_controller_data* c){
	struct timeval now;

	/* getnstimeofday function is used by PF_RING 4.7.1 to get the time */
	do_gettimeofday(&now);

	c->integral = 0;
	c->previous_deviation = 0;
	c->previous_t = now;
	spin_lock_init(&c->lock);
}





/* ****************  local helper functions  ******************** */


/* ****************  public functions  ******************** */

/* Updates pid controller internal values, returns the controlling parameters
 * for the current packet. Those parameters are used to calculate the dynamic
 * sampling limit
 *
 * @param now arrival time of new packet
 * @param deviation current deviation of ring buffer target fill level
 * @param pid out new controller values, unweighted
 */
void cctrack_controller_new_packet(struct cctrack_per_ring_data *this_ring_data,
		struct timeval now, s32 deviation,
		struct cctrack_pid_controller *pid)
{
	s64 now_ns; /* now in nanoseconds */
	s64 prev_ns; /* previous packet arrival in nanoseconds */
	s64 delta_t_ns; /* delta time nanoseconds since last packet arrival */
	s32 delta_t_msec;

	s64 integral;

	struct cctrack_pid_controller_data *pid_controller_data =
			&this_ring_data->pid_controller_data;

	// note the way WHEN we divide to keep numerical error small
	// that's why we calculate with MSEC but result is in SEC

	now_ns = timeval_to_ns(&now);
	cctrack_assert(now_ns > 0);

	spin_lock(&pid_controller_data->lock);

	prev_ns = timeval_to_ns(&pid_controller_data->previous_t);
	cctrack_assert(prev_ns > 0);

	/* now >= prev or they differ at most in only a second due to
	 * reordering */
	cctrack_assert(now_ns >= prev_ns ||
			(prev_ns - now_ns > 0 && prev_ns - now_ns < NSEC_PER_SEC));

	delta_t_ns = now_ns - prev_ns;
	if(now_ns < prev_ns) delta_t_ns *= -1; /* see previous assertion */

	cctrack_assert(delta_t_ns >= 0);

#ifdef DEBUG
	if(!((delta_t_ns/NSEC_PER_SEC) < 3600)) {
		printk("(delta_t_ns/NSEC_PER_SEC) < 3600");
		printk("delta_t_ns: %lld, delta_t_ms:%lld delta_t_s:%lld\n",
				delta_t_ns, delta_t_ns/NSEC_PER_MSEC, delta_t_ns/NSEC_PER_SEC);
	}
	/* assertion failed */
	if(!(now_ns >= prev_ns ||
			(prev_ns - now_ns > 0 && prev_ns - now_ns < NSEC_PER_SEC))){
		printk("now_ns prev_ns: %lld %lld delta_t_ns: %lld\n",
				now_ns, prev_ns, delta_t_ns);
	}
#endif
	cctrack_assert((delta_t_ns/NSEC_PER_SEC) < 3600); /* one packet per hour*/
	cctrack_assert(delta_t_ns >= 0);

	delta_t_msec = (s32)(delta_t_ns/NSEC_PER_MSEC);
	cctrack_assert((s64)delta_t_msec == delta_t_ns/NSEC_PER_MSEC);
	cctrack_assert(delta_t_msec/MSEC_PER_SEC < 3600); /* one packet per hour*/
	cctrack_assert(delta_t_msec >= 0);

	if(delta_t_msec == 0) delta_t_msec = 1; /* discretization, no div by 0 */
	cctrack_assert(delta_t_msec > 0);

	/* proportional */
	pid->proportional = deviation;

	/* integral */
	// integral is in seconds to keep number small
	integral = (s64)((s64)delta_t_msec * (s64)deviation);
	cctrack_assert(!(deviation < 0) || integral < (s64)0);
	cctrack_assert(!(deviation > 0) || integral > (s64)0);
	integral = integral / MSEC_PER_SEC;
	integral += pid_controller_data->integral;

	//INT_MIN <= integral <= INT_MAX;
	if(integral <= (s64)INT_MIN) integral = (s64)INT_MIN;
	if((s64)INT_MAX <= integral) integral = (s64)INT_MAX;
	cctrack_assert(integral >= (s64)INT_MIN);
	cctrack_assert((s64)INT_MAX >= integral);
	cctrack_assert((s32)integral == integral);

	pid_controller_data->integral = integral;
	pid->integral = (s32)integral;

	/* differential */
	// differential is in seconds to be more accurate
	pid->derivate =
		((deviation - pid_controller_data->previous_deviation)*
				MSEC_PER_SEC)
		/
		(delta_t_msec);

	pid_controller_data->previous_t = now;
	pid_controller_data->previous_deviation = deviation;

	spin_unlock(&pid_controller_data->lock);
}



/*** get_pid_divisor_P and get_pid_divisor_D, generated by macro magic ***/

/*
 * Macro for returing the divisor with additional error checking
 * params: struct cctrack_pid_controller_params
 * X: P, I, D
 * extra: s32 evaluated once
 */
#define GEN_GET_PID_DIVISOR(params, X, extra) \
		cctrack_assert(params->K_##X##_divisor > 0); \
		cctrack_assert(params->K_##X##_divisor_extra == 0 || \
						params->K_##X##_divisor_extra == 1); \
		if(!params->K_##X##_divisor_extra){ \
			return params->K_##X##_divisor; \
		}else{ \
			s64 __res = (s64)params->K_##X##_divisor; \
			s64 __extra = (s64)(extra); \
			cctrack_assert(__extra != 0); \
			cctrack_assert(__extra > 0); \
			if(__extra <= 0) __extra = 1; /* emergency fix */ \
			__res *= extra; \
			cctrack_assert(__res >= INT_MIN && __res <= INT_MAX); \
			cctrack_assert(__res == (s64)((s32)__res)); \
			cctrack_assert(__res > 0); \
			return (s32)__res; \
		}


s32 get_pid_divisor_P(struct cctrack_pid_controller_params *params, s32 extra){
	GEN_GET_PID_DIVISOR(params, P, extra)
}

s32 inline get_pid_divisor_I(struct cctrack_pid_controller_params *params){
	return params->K_I_divisor;
}

s32 get_pid_divisor_D(struct cctrack_pid_controller_params *params, s32 extra){
	GEN_GET_PID_DIVISOR(params, D, extra)
}
